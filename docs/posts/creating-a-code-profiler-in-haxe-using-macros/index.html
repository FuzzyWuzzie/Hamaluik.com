<!DOCTYPE html> <html lang="en-CA"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1"> <title>Creating a Code Profiler in Haxe Using Macros</title> <link rel="alternate" type="application/rss+xml" href="https://blog.hamaluik.ca/feed.rss" title="Posts RSS"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"> <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"> <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"> <link rel="manifest" href="/site.webmanifest"> <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#ff5555"> <meta name="msapplication-TileColor" content="#ff5555"> <meta name="theme-color" content="#ff5555"> <meta property="og:title" content="Creating a Code Profiler in Haxe Using Macros"/> <meta property="og:url" content="http://blog.hamaluik.ca/posts/creating-a-code-profiler-in-haxe-using-macros/"/> <meta property="og:image" content="https://og-image.now.sh/Creating%20a%20Code%20Profiler%20in%20Haxe%20Using%20Macros.png?theme=light&md=0&fontSize=75px&images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fhyper-color-logo.svg&widths=350&heights=350"/> <meta property="og:description" content="Haxe macros are said by many to be “black magic”, and in some ways they are—macros in Haxe are actual Haxe code (rather than macros in C&#x2F;C++ for example, which are just fancy pre-processor directives). Macros are undoubtedly the most advanced feature of Haxe and probably the hardest to grasp, however I think a major reason for that is a lack of really solid documentation on the subject. To me, the Haxe docs regarding macros are somewhat obfuscated and leave something to be desired, and unfortunately there’s not a lot of other resources online. This is what led me to embark on my own journey of learning Haxe macros, and hopefully starting to shed a little more light on their mystery."/> <meta property="og:type" content="article"/> <meta property="og:locale" content="en_CA"/> <meta property="og:site_name" content="Kenton Hamaluik"/> <meta property="article:published_time" content=" 2015-03-31T05:21:55+00:00 "/> <meta property="article:author" content="http://blog.hamaluik.ca/"/> <meta property="article:tag" content="Haxe"/> <meta name="twitter:card" content="summary_large_image"/> <meta name="twitter:image:alt" content="Creating a Code Profiler in Haxe Using Macros"/> <style> @font-face {font-family:"Crimson Pro";font-style:italic;font-weight:400;font-display:swap;src:local("Crimson Pro Italic"),local("CrimsonPro Italic"),local("Crimson-Pro-Italic"),local("CrimsonPro-Italic"),url(/fonts/crimson-pro-normal-latin-ext.woff2) format("woff2"),url(/fonts/CrimsonPro-Italic.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Crimson Pro";font-style:italic;font-weight:400;font-display:swap;src:local("Crimson Pro Italic"),local("CrimsonPro Italic"),local("Crimson-Pro-Italic"),local("CrimsonPro-Italic"),url(/fonts/crimson-pro-italic-latin.woff2) format("woff2"),url(/fonts/CrimsonPro-Italic.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:400;font-display:swap;src:local("Crimson Pro"),local("CrimsonPro"),local("Crimson-Pro"),local("CrimsonPro"),url(/fonts/crimson-pro-normal-latin-ext.woff2) format("woff2"),url(/fonts/CrimsonPro-Regular.ttf.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:400;font-display:swap;src:local("Crimson Pro"),local("CrimsonPro"),local("Crimson-Pro"),local("CrimsonPro"),url(/fonts/crimson-pro-normal-latin.woff2) format("woff2"),url(/fonts/CrimsonPro-Regular.ttf.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:700;font-display:swap;src:local("Crimson Pro Bold"),local("CrimsonPro Bold"),local("Crimson-Pro-Bold"),local("CrimsonPro-Bold"),url(/fonts/crimson-pro-bold-latin-ext.woff2) format("woff2"),url(/fonts/CrimsonPro-Bold.ttf.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Crimson Pro";font-style:normal;font-weight:700;font-display:swap;src:local("Crimson Pro Bold"),local("CrimsonPro Bold"),local("Crimson-Pro-Bold"),local("CrimsonPro-Bold"),url(/fonts/crimson-pro-bold-latin.woff2) format("woff2"),url(/fonts/CrimsonPro-Bold.ttf.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}@font-face {font-family:"Eczar";font-style:normal;font-weight:700;font-display:swap;src:local("Eczar Bold"),local("Eczar-Bold"),url(/fonts/eczar-bold-latin-ext.woff2) format("woff2"),url(/fonts/Eczar-Bold.ttf.ttf) format("ttf");unicode-range:U+0100-024F,U+0259,U+1E00-1EFF,U+2020,U+20A0-20AB,U+20AD-20CF,U+2113,U+2C60-2C7F,U+A720-A7FF;}@font-face {font-family:"Eczar";font-style:normal;font-weight:700;font-display:swap;src:local("Eczar Bold"),local("Eczar-Bold"),url(/fonts/eczar-bold-latin.woff2) format("woff2"),url(/fonts/Eczar-Bold.ttf.ttf) format("ttf");unicode-range:U+0000-00FF,U+0131,U+0152-0153,U+02BB-02BC,U+02C6,U+02DA,U+02DC,U+2000-206F,U+2074,U+20AC,U+2122,U+2191,U+2193,U+2212,U+2215,U+FEFF,U+FFFD;}:root{--theme-background:#282a36;--theme-currentline:#44475a;--theme-selection:#44475a;--theme-foreground:#f8f8f2;--theme-comment:#6272a4;--theme-cyan:#8be9fd;--theme-green:#50fa7b;--theme-orange:#ffb86c;--theme-pink:#ff79c6;--theme-purple:#bd93f9;--theme-red:#ff5555;--theme-yellow:#f1fa8c;}body{margin:1em auto;max-width:36em;line-height:1.2;color:var(--theme-background);background:var(--theme-foreground);padding:0 0.5em;font-family:"Crimson Pro",Constantia,"Lucida Bright",Lucidabright,"Lucida Serif",Lucida,"DejaVu Serif","Bitstream Vera Serif","Liberation Serif",Georgia,serif;font-size:16pt;}h1,h2,h3{line-height:1.2;font-family:"Eczar",Constantia,"Lucida Bright",Lucidabright,"Lucida Serif",Lucida,"DejaVu Serif","Bitstream Vera Serif","Liberation Serif",Georgia,serif;font-weight:800;font-size:32pt;margin-bottom:0;}h2{font-size:28pt;}h3{font-size:20pt;}h1 a,h2 a,h3 a{text-decoration:none;}body>header>h1{font-size:48pt;font-weight:800;}p{text-align:justify;margin:0;hyphens:auto;}p+p{text-indent:2em;}a{color:var(--theme-background);text-decoration:underline;text-decoration-color:var(--theme-red);}body>header>h1{margin:0;padding:0;border-bottom:5px dashed var(--theme-red);line-height:1;}body>header>h1>a{font-style:normal;word-break:normal;}a:hover,a:focus,a:active{color:var(--theme-red);text-decoration:none;}ul.postlist{padding:0;list-style-type:none;margin-top:0;margin-bottom:1em;}ul.postlist>li::before{width:1em;height:1em;margin-left:-1em;display:inline-flex;align-items:center;justify-content:start;}ul.postlist>li{padding-left:1em;}ul.postlist>li a{text-decoration:none;}ul.postlist>li>time,article>header>h1>time{font-size:10pt;color:var(--theme-red);font-weight:normal;font-family:"Crimson Pro",Constantia,"Lucida Bright",Lucidabright,"Lucida Serif",Lucida,"DejaVu Serif","Bitstream Vera Serif","Liberation Serif",Georgia,serif;}ul:not(.postlist)>li{overflow-wrap:break-word;}article figure{display:block;text-align:center;}article figure img,article figure video{max-width:100%;}img.white{mix-blend-mode:multiply;}article figure figcaption{display:block;font-size:10pt;text-align:center;margin-bottom:0.5em;}:not(pre)>code{word-break:break-all;font-family:"Source Code Pro","Fira Code","Fira Mono",Consolas,"Andale Mono WT","Andale Mono","Lucida Console","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;font-size:0.75em;}pre,figure{overflow-x:auto;}body>header{margin-bottom:1em;}footer{font-size:10pt;margin-top:1em;border-top:5px dashed var(--theme-red);padding-top:0.5em;display:flex;flex-direction:column;align-items:flex-start;}footer a.has-icon{display:inline-flex;flex-direction:row;align-items:center;}footer a.has-icon>svg{margin-right:0.5em;}footer svg{width:auto;height:1em;fill:currentColor;stroke:currentColor;}blockquote{border-left:5px dashed var(--theme-red);margin:1em;padding:0 calc(0.5em + 4px) 0 0.5em;}footer>span{display:block;}svg{color:var(--theme-background);fill:currentColor;}@media (prefers-color-scheme:dark){body{background-color:var(--theme-background);color:var(--theme-foreground);}a{color:var(--theme-foreground);text-decoration-color:var(--theme-cyan);}svg{color:var(--theme-foreground);fill:currentColor;}body>header>h1{border-bottom-color:var(--theme-cyan);}ul.postlist>li>time,article>header>h1>time{color:var(--theme-cyan);}:not(pre)>code{}footer{border-top-color:var(--theme-cyan);}blockquote{border-left-color:var(--theme-cyan);}.highlight{background:#21222c;}img.white{filter:invert(100%) hue-rotate(180deg);mix-blend-mode:screen;}}.highlight{font-family:"Source Code Pro","Fira Code","Fira Mono",Consolas,"Andale Mono WT","Andale Mono","Lucida Console","Lucida Sans Typewriter","DejaVu Sans Mono","Bitstream Vera Sans Mono","Liberation Mono","Nimbus Mono L",Monaco,"Courier New",Courier,monospace;font-size:12pt;padding:0.25em;background:var(--theme-background);color:var(--theme-foreground);margin:1em 0;}.highlight>pre{margin:0;}.highlight{background:var(--theme-background);color:var(--theme-foreground);}.highlight .hll{background-color:var(--theme-yellow);}.highlight .c{color:var(--theme-comment);}.highlight .err{color:var(--theme-foreground);}.highlight .g{color:var(--theme-foreground);}.highlight .k{color:var(--theme-pink);}.highlight .l{color:var(--theme-foreground);}.highlight .n{color:var(--theme-foreground);}.highlight .o{color:var(--theme-pink);}.highlight .x{color:var(--theme-foreground);}.highlight .p{color:var(--theme-foreground);}.highlight .ch{color:var(--theme-comment);}.highlight .cm{color:var(--theme-comment);}.highlight .cp{color:var(--theme-pink);}.highlight .cpf{color:var(--theme-comment);}.highlight .c1{color:var(--theme-comment);}.highlight .cs{color:var(--theme-comment);}.highlight .gd{color:#8b080b;}.highlight .ge{color:var(--theme-foreground);text-decoration:underline;}.highlight .gr{color:var(--theme-foreground);}.highlight .gh{color:var(--theme-foreground);font-weight:bold;}.highlight .gi{color:var(--theme-foreground);font-weight:bold;}.highlight .go{color:var(--theme-currentline);}.highlight .gp{color:var(--theme-foreground);}.highlight .gs{color:var(--theme-foreground);}.highlight .gu{color:var(--theme-foreground);font-weight:bold;}.highlight .gt{color:var(--theme-foreground);}.highlight .kc{color:var(--theme-pink);}.highlight .kd{color:var(--theme-cyan);font-style:italic;}.highlight .kn{color:var(--theme-pink);}.highlight .kp{color:var(--theme-pink);}.highlight .kr{color:var(--theme-pink);}.highlight .kt{color:var(--theme-cyan);}.highlight .ld{color:var(--theme-foreground);}.highlight .m{color:var(--theme-purple);}.highlight .s{color:var(--theme-yellow);}.highlight .na{color:var(--theme-green);}.highlight .nb{color:var(--theme-cyan);font-style:italic;}.highlight .nc{color:var(--theme-green);}.highlight .no{color:var(--theme-foreground);}.highlight .nd{color:var(--theme-foreground);}.highlight .ni{color:var(--theme-foreground);}.highlight .ne{color:var(--theme-foreground);}.highlight .nf{color:var(--theme-green);}.highlight .nl{color:var(--theme-cyan);font-style:italic;}.highlight .nn{color:var(--theme-foreground);}.highlight .nx{color:var(--theme-foreground);}.highlight .py{color:var(--theme-foreground);}.highlight .nt{color:var(--theme-pink);}.highlight .nv{color:var(--theme-cyan);font-style:italic;}.highlight .ow{color:var(--theme-pink);}.highlight .w{color:var(--theme-foreground);}.highlight .mb{color:var(--theme-purple);}.highlight .mf{color:var(--theme-purple);}.highlight .mh{color:var(--theme-purple);}.highlight .mi{color:var(--theme-purple);}.highlight .mo{color:var(--theme-purple);}.highlight .sa{color:var(--theme-yellow);}.highlight .sb{color:var(--theme-yellow);}.highlight .sc{color:var(--theme-yellow);}.highlight .dl{color:var(--theme-yellow);}.highlight .sd{color:var(--theme-yellow);}.highlight .s2{color:var(--theme-yellow);}.highlight .se{color:var(--theme-yellow);}.highlight .sh{color:var(--theme-yellow);}.highlight .si{color:var(--theme-yellow);}.highlight .sx{color:var(--theme-yellow);}.highlight .sr{color:var(--theme-yellow);}.highlight .s1{color:var(--theme-yellow);}.highlight .ss{color:var(--theme-yellow);}.highlight .bp{color:var(--theme-foreground);font-style:italic;}.highlight .fm{color:var(--theme-green);}.highlight .vc{color:var(--theme-cyan);font-style:italic;}.highlight .vg{color:var(--theme-cyan);font-style:italic;}.highlight .vi{color:var(--theme-cyan);font-style:italic;}.highlight .vm{color:var(--theme-cyan);font-style:italic;}.highlight .il{color:var(--theme-purple);}.slideshow{width:512px;box-sizing:border-box;text-align:center;overflow:hidden;margin:0 auto;}.slideshow a{display:inline-flex;width:1.5rem;height:1.5rem;background:var(--theme-foreground);color:var(--theme-background);text-decoration:none;align-items:center;justify-content:center;border-radius:50%;margin:0 0 0.5rem 0;position:relative;}.slideshow a:focus,.slideshow a:hover,.slideshow a:active{color:var(--theme-foreground);background:var(--theme-background);}@supports (scroll-snap-type){.slideshow a{display:none;}}.slideshow .slides{display:flex;overflow-x:auto;scroll-snap-type:x mandatory;scroll-behavior:smooth;-webkit-overflow-scrolling:touch;scrollbar-width:thin;scrollbar-color:var(--theme-foreground) transparent;}.slideshow .slides img{scroll-snap-align:start;flex-shrink:0;width:512px;height:512px;margin-right:50px;border-radius:10px;transform-origin:center center;transform:scale(1);transition:transform 0.5s;position:relative;}.slideshow .slides::-webkit-scrollbar{width:10px;height:10px;}.slideshow .slides::-webkit-scrollbar-thumb{background:var(--theme-foreground);border-radius:10px;}.slideshow .slides::-webkit-scrollbar-track{background:transparent;}@media (prefers-color-scheme:dark){.slideshow a{color:var(--theme-foreground);background:var(--theme-background);}.slideshow a:focus,.slideshow a:hover,.slideshow a:active{background:var(--theme-foreground);color:var(--theme-background);}}</style> </head> <body> <header> <h1><a href="https://blog.hamaluik.ca/">Kenton Hamaluik</a></h1> </header> <article> <header> <h1> Creating a Code Profiler in Haxe Using Macros <time datetime='2015-03-31T05:21:55+00:00'>(2015-03-31)</time> </h1> </header> <p><a href="http://haxe.org/manual/macro.html">Haxe macros</a> are said by many to be “black magic”, and in some ways they are—macros in Haxe are actual Haxe code (rather than macros in C/C++ for example, which are just fancy pre-processor directives). Macros are undoubtedly the most advanced feature of Haxe and probably the hardest to grasp, however I think a major reason for that is a lack of really solid documentation on the subject. To me, the Haxe docs regarding macros are somewhat obfuscated and leave something to be desired, and unfortunately there’s not a lot of other resources online. This is what led me to embark on my own journey of learning Haxe macros, and hopefully starting to shed a little more light on their mystery.</p> <p>I had some trouble getting this example off the ground, so I would like to thank <a href="https://github.com/ousado">ousado</a> for helping me out on the <a href="http://webchat.freenode.net/?channels=haxe">Haxe IRC</a>. Haxe is truly a great and supportive community, and if you’re ever stuck with something I strongly encourage you to pop on the IRC—you’re bound to have someone help you out!</p> <p>I think I first realized the potential of Haxe macros after reading <a href="http://underscorediscovery.com/">underscorediscovery</a>’s <a href="http://notes.underscorediscovery.com/haxe-compile-time-macros/">post</a> on the subject—before that I had largely ignored macros as I got on just fine without them. Then I saw something that caught my eye: <em>profiling and instrumentation</em>. I’m currently working on formalizing my personal game engine (<a href="https://github.com/BlazingMammothGames/Woolli">Woolli</a>) that I’ve somewhat developed during the course of some projects. The engine is an entity-component-system engine. Right now there is very limited profiling support through inheritence on the systems that are used (but <em>none</em> of the engine code is profiled). Although this isn’t much of a problem yet as things <em>seem</em> to run smoothly, I just know that one day things are going to break down and when that day comes, a profiler will be an invaluable tool to have. Anyway: back to <a href="http://underscorediscovery.com/">underscorediscovery</a>’s post. In it, he mentions the possibility for doing such a thing but declines to dig into any code. What a shame! Naturally, I’ve attempted to bridge that gap by writing some code which I will present here.</p> <p>Since I also want this to be a bit of a learning experience rather than just a code dump, I will attempt to walk you through what I achieved, how I achieved it, and why I did the things that I did. I’ll also show you some of my false starts so you can hopefully learn from my mistakes!</p> <h2><a href="#a-brief-introduction-to-haxe-macros" aria-hidden="true" class="anchor" id="headera-brief-introduction-to-haxe-macros"></a>A Brief Introduction to Haxe Macros</h2> <p>There are three main types of Haxe macros:</p> <ol> <li>Expression macros (these are simple functions that can be placed pretty much anywhere in your code for macro-ey goodness)</li> <li>Build macros (these are applied at compilation time using the <code>@:build</code> metadata and are generally used for modifying code in-place)</li> <li>Initialization macros (these use the <code>--macro</code> command line parameter)</li> </ol> <p>So far I’ve only used expression and build macros, so I can’t comment much on initialization macros. Expression and build macros are easy to set up—the trick lies in thinking like the compiler to get things done properly. For the profiling code I’m writing, a <strong>build</strong> macro is the most suitable as I want to go through all of a class’ functions and modify them (rather than have to explicitely call a function like I would with an expression macro).</p> <h3><a href="#build-macros" aria-hidden="true" class="anchor" id="headerbuild-macros"></a>Build Macros</h3> <p>Build macros get applied to your classes generally through one of two ways: using an <code>@:build</code> or an <code>@:autoBuild</code> <a href="http://haxe.org/manual/cr-metadata.html">metadata</a>. The difference between these two macros is that <code>@:build</code> macros get applied only to the class they’re written on top of, whereas <code>@:autoBuild</code> macros get applied only to the descendets of the class they’re written above. See the example below to see what I mean:</p> <div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * This will be the class that applies the build macro to other classes</span>
<span class="cm"> */</span>
<span class="kd">class</span> <span class="n">Profiler</span>
<span class="p">{</span>
    <span class="kd">macro</span> <span class="kd">public</span> <span class="kd">static</span> <span class="kd">function</span> <span class="nf">profile</span><span class="p">():</span><span class="n">Array</span><span class="p">&lt;</span><span class="n">Field</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="c1">// do nothing for now</span>
        <span class="k">return</span> <span class="n">Context</span><span class="p">.</span><span class="n">getBuildFields</span><span class="p">();</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * When this class gets compiled, the Profiler.profile() function will be</span>
<span class="cm"> * called (with the context within the class)</span>
<span class="cm"> */</span>
<span class="nd">@:build(</span><span class="n">Profiler</span><span class="p">.</span><span class="n">profile</span><span class="p">()</span><span class="nd">)</span>
<span class="kd">class</span> <span class="n">ProfiledClassA</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">()</span> <span class="p">{}</span>

    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">doSomething</span><span class="p">():</span><span class="n">Float</span> <span class="p">{</span> <span class="k">return</span> <span class="mf">3.141592</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * When this class gets compiled, the Profiler.profile() WON&#39;T be called on it</span>
<span class="cm"> * (though it will be called on its descendents)</span>
<span class="cm"> */</span>
<span class="nd">@:autoBuild(</span><span class="n">Profiler</span><span class="p">.</span><span class="n">profile</span><span class="p">()</span><span class="nd">)</span>
<span class="kd">class</span> <span class="n">ProfiledClassB</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">()</span> <span class="p">{}</span>

    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">doSomethingElse</span><span class="p">():</span><span class="n">Float</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">5</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * When this class gets compiled, the Profiler.profile() will be called on it</span>
<span class="cm"> * (since it inherits from ProfiledClassB which has `@:autoBuild` on it)</span>
<span class="cm"> */</span>
<span class="kd">class</span> <span class="n">ProfiledClassC</span> <span class="kd">extends</span> <span class="n">ProfiledClassB</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">()</span> <span class="p">{}</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * When this class or any class that inherits from it gets compiled, the</span>
<span class="cm"> * Profiler.profile() function will be called</span>
<span class="cm"> */</span>
<span class="nd">@:build(</span><span class="n">Profiler</span><span class="p">.</span><span class="n">profile</span><span class="p">()</span><span class="nd">)</span>
<span class="nd">@:autoBuild(</span><span class="n">Profiler</span><span class="p">.</span><span class="n">profile</span><span class="p">()</span><span class="nd">)</span>
<span class="kd">class</span> <span class="n">ProfiledClassD</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">()</span> <span class="p">{}</span>

    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">doSomethingElseEntirely</span><span class="p">():</span><span class="n">Float</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>Hopefully that makes sense. If not, please leave a comment below and I’ll try to help you out!</p> <h2><a href="#profiling" aria-hidden="true" class="anchor" id="headerprofiling"></a>Profiling</h2> <p>In order to profile my code I want to be able to measure the execution time of each function (as well as how many times any given function was called). If I were to do this manually, I would change something like this:</p> <div class="highlight"><pre><span></span><span class="kd">class</span> <span class="n">SomeClass</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">doSomething</span><span class="p">():</span><span class="n">Float</span>
    <span class="p">{</span>
        <span class="kd">var</span> x<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">100000</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>into something like:</p> <div class="highlight"><pre><span></span><span class="kd">class</span> <span class="n">SomeClass</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">()</span> <span class="p">{}</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">doSomething</span><span class="p">():</span><span class="n">Float</span>
    <span class="p">{</span>
        <span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="s1">&#39;SomeClass&#39;</span><span class="p">,</span> <span class="s1">&#39;doSomething&#39;</span><span class="p">);</span>
        <span class="kd">var</span> x<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span><span class="p">(</span><span class="n">i</span> <span class="k">in</span> <span class="mi">0</span><span class="o">...</span><span class="mi">100000</span><span class="p">)</span>
            <span class="n">x</span> <span class="o">+=</span> <span class="mf">0.1</span><span class="p">;</span>
        <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="s1">&#39;SomeClass&#39;</span><span class="p">,</span> <span class="s1">&#39;doSomething&#39;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>Here, the <code>startProfile</code> function would be responsible for recording a timestamp of when the function began and <code>endProfile</code> would be responsible for recording a timestamp of when the function finished and adding the time difference between the two to the function’s elapsed time. Here is a profiling class that does exactly that:</p> <div class="highlight"><pre><span></span><span class="kd">typedef</span> <span class="n">MethodProfile</span> <span class="o">=</span> <span class="p">{</span>
    <span class="kd">var</span> calls<span class="p">:</span><span class="n">Int</span><span class="p">;</span>
    <span class="kd">var</span> startTime<span class="p">:</span><span class="n">Float</span><span class="p">;</span>
    <span class="kd">var</span> elapsedTime<span class="p">:</span><span class="n">Float</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">class</span> <span class="n">Profiler</span>
<span class="p">{</span>
    <span class="kd">private</span> <span class="kd">static</span> <span class="kd">var</span> profiles<span class="p">:</span><span class="n">StringMap</span><span class="p">&lt;</span><span class="n">StringMap</span><span class="p">&lt;</span><span class="n">MethodProfile</span><span class="p">&gt;&gt;</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringMap</span><span class="p">&lt;</span><span class="n">StringMap</span><span class="p">&lt;</span><span class="n">MethodProfile</span><span class="p">&gt;&gt;();</span>

    <span class="cm">/**</span>
<span class="cm">     * Reset all the profiling information. Doing this before reading / printing the information will</span>
<span class="cm">     * cause all the data collected since the beginning (or last reset) to be lost</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">function</span> <span class="nf">reset</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">profiles</span> <span class="o">=</span> <span class="k">new</span> <span class="n">StringMap</span><span class="p">&lt;</span><span class="n">StringMap</span><span class="p">&lt;</span><span class="n">MethodProfile</span><span class="p">&gt;&gt;();</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Called at the start of a function to record when in time the method was called. This must always</span>
<span class="cm">     * be called BEFORE an endProfile() call is made</span>
<span class="cm">     * @param    className    the fully-qualified class name of the method&#39;s class</span>
<span class="cm">     * @param    methodName    the name of the method being profiled</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">function</span> <span class="nf">startProfile</span><span class="p">(</span><span class="n">className</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">methodName</span><span class="p">:</span><span class="n">String</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// make sure the profiles exist</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profiles</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">className</span><span class="p">))</span>
            <span class="n">profiles</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">className</span><span class="p">,</span> <span class="k">new</span> <span class="n">StringMap</span><span class="p">&lt;</span><span class="n">MethodProfile</span><span class="p">&gt;());</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">exists</span><span class="p">(</span><span class="n">methodName</span><span class="p">))</span>
            <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">set</span><span class="p">(</span><span class="n">methodName</span><span class="p">,</span> <span class="p">{</span> <span class="n">calls</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">startTime</span><span class="p">:</span> <span class="mi">0</span><span class="p">,</span> <span class="n">elapsedTime</span><span class="p">:</span> <span class="mi">0</span> <span class="p">}</span> <span class="p">);</span>

        <span class="cp">#if DEBUG_PROFILING</span> <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;&gt; Starting &quot;</span> <span class="o">+</span> <span class="n">className</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">methodName</span><span class="p">);</span> <span class="cp">#end</span>

        <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">methodName</span><span class="p">).</span><span class="n">calls</span><span class="o">++</span><span class="p">;</span>
        <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">methodName</span><span class="p">).</span><span class="n">startTime</span> <span class="o">=</span> <span class="n">Sys</span><span class="p">.</span><span class="n">cpuTime</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Called at the end of a function to calculate the method&#39;s execution time. This must always</span>
<span class="cm">     * be called AFTER a startProfile() call</span>
<span class="cm">     * @param    className    the fully-qualified class name of the method&#39;s class</span>
<span class="cm">     * @param    methodName    the name of the method being profiled</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">function</span> <span class="nf">endProfile</span><span class="p">(</span><span class="n">className</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">methodName</span><span class="p">:</span><span class="n">String</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kd">var</span> t<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">Sys</span><span class="p">.</span><span class="n">cpuTime</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">profiles</span><span class="p">.</span><span class="n">exists</span><span class="p">(</span><span class="n">className</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">exists</span><span class="p">(</span><span class="n">methodName</span><span class="p">))</span>
            <span class="k">throw</span> <span class="s2">&quot;EndProfile was called on a function that was never started!&quot;</span><span class="p">;</span>

        <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">methodName</span><span class="p">).</span><span class="n">elapsedTime</span> <span class="o">+=</span> <span class="n">t</span> <span class="o">-</span> <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">methodName</span><span class="p">).</span><span class="n">startTime</span><span class="p">;</span>
        <span class="cp">#if DEBUG_PROFILING</span> <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;&lt; Ending &quot;</span> <span class="o">+</span> <span class="n">className</span> <span class="o">+</span> <span class="s2">&quot;.&quot;</span> <span class="o">+</span> <span class="n">methodName</span><span class="p">);</span> <span class="cp">#end</span>
    <span class="p">}</span>

    <span class="cm">/**</span>
<span class="cm">     * Just a utility function to print the profiling data, separated by class.</span>
<span class="cm">     */</span>
    <span class="kd">public</span> <span class="kd">static</span> <span class="kd">function</span> <span class="nf">printProfiles</span><span class="p">():</span><span class="n">Void</span>
    <span class="p">{</span>
        <span class="kd">var</span> totalTime<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">className</span> <span class="k">in</span> <span class="n">profiles</span><span class="p">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="p">{</span>
            <span class="kd">var</span> classTime<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
            <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="n">className</span> <span class="o">+</span> <span class="s2">&quot;:&quot;</span><span class="p">);</span>
            <span class="k">for</span> <span class="p">(</span><span class="n">methodName</span> <span class="k">in</span> <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">keys</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;  .&quot;</span> <span class="o">+</span> <span class="n">methodName</span> <span class="o">+</span> <span class="s2">&quot;: &quot;</span> <span class="o">+</span> <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">methodName</span><span class="p">).</span><span class="n">elapsedTime</span> <span class="o">+</span> <span class="s2">&quot;s (&quot;</span> <span class="o">+</span> <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">methodName</span><span class="p">).</span><span class="n">calls</span> <span class="o">+</span> <span class="s2">&quot; calls)&quot;</span><span class="p">);</span>
                <span class="n">classTime</span> <span class="o">+=</span> <span class="n">profiles</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">className</span><span class="p">).</span><span class="n">get</span><span class="p">(</span><span class="n">methodName</span><span class="p">).</span><span class="n">elapsedTime</span><span class="p">;</span>
            <span class="p">}</span>
            <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;  ---&quot;</span><span class="p">);</span>
            <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;  &quot;</span> <span class="o">+</span> <span class="n">classTime</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">);</span>
            <span class="n">totalTime</span> <span class="o">+=</span> <span class="n">classTime</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;&quot;</span><span class="p">);</span>
        <span class="n">Lib</span><span class="p">.</span><span class="n">println</span><span class="p">(</span><span class="s2">&quot;Total time: &quot;</span> <span class="o">+</span> <span class="n">totalTime</span> <span class="o">+</span> <span class="s2">&quot;s&quot;</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>I made the above fairly verbose so it’s easy to see what’s going on. The <code>startProfile</code> and <code>endProfile</code> functions should work exactly as I’ve described them to, and we could use them exactly like I’ve already mentioned: calling <code>startProfile</code> at the start of the function and <code>endProfile</code> at the end of the function—but that would be tedious and prone to errors (what if we forgot to include those function calls somewhere else?). It would also tend to clutter our code up something fierce and then the profiling code would still be there on a release build (which would be entirely unnecessary!). This is where a Haxe macro will come very much in handy, as it will automatically transform our code for us to insert those profiling calls for debug builds and do nothing for release builds.</p> <h2><a href="#bringing-in-the-macro" aria-hidden="true" class="anchor" id="headerbringing-in-the-macro"></a>Bringing in the Macro</h2> <p>What we want the macro to do is loop through every function in a given class, and before any other statement in the class, we want to add the <a href="http://haxe.org/manual/expression.html">expression</a> <code>Profiler.startProfile(className, methodName);</code>. The end the profiling, we have to be a little bit more careful about how we deal with return statements—if we were to simply tack on a call to <code>Profiler.endProfile(className, methodName);</code> at the end of the function it would never be reached for any function that has a return statement anywhere, for example:</p> <div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * The base function we want to profile</span>
<span class="cm"> */</span>
<span class="kd">function</span> <span class="nf">example</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">Bool</span><span class="p">):</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">39</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/**</span>
<span class="cm"> * The &quot;naively&quot; profiled function</span>
<span class="cm"> */</span>
<span class="kd">function</span> <span class="nf">example</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">Bool</span><span class="p">):</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span> <span class="c1">// this would be injected at the start of the function by our macro</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span> <span class="c1">// if we get here, the function will immediately return and _not_ call `endProfile`</span>
    <span class="k">return</span> <span class="mi">39</span><span class="p">;</span>
    <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span> <span class="c1">// this code will _never_ be reached (the function returns before we get to it!)</span>
<span class="p">}</span>
</pre></div> <p>What we instead want to do is transform any return statements into a block that looks like:</p> <div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kd">var</span> ___tempProfilingReturnValue <span class="o">=</span> <span class="n">$oldReturnExpression</span><span class="p">;</span>
    <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">___tempProfilingReturnValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div> <p>This way we can not only capture the execution time of the return expression (this would be important if you did something like <code>return someReallySlowFunction();</code>), but also ensure that our <code>endProfile</code> function gets called no matter where the function exits. Note that we will also have to make sure that if the final statement in a function isn’t <code>return ...</code> then we still need to tack on the <code>endProfile</code> statement onto the end of the function.</p> <p>Thus we would want to transform our example function into the following:</p> <div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">example</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">Bool</span><span class="p">):</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kd">var</span> ___tempProfilingReturnValue <span class="o">=</span> <span class="mi">42</span><span class="p">;</span>
            <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span>
            <span class="k">return</span> <span class="n">___tempProfilingReturnValue</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">{</span>
        <span class="kd">var</span> ___tempProfilingReturnValue <span class="o">=</span> <span class="mi">39</span><span class="p">;</span>
        <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="s2">&quot;example&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">___tempProfilingReturnValue</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>Once this logic makes sense to you, we can move on to actually implementing the macro.</p> <h3><a href="#implementing-the-macro" aria-hidden="true" class="anchor" id="headerimplementing-the-macro"></a>Implementing the Macro</h3> <p>First things first, we need to define our macro function. The syntax for a build macro function is as follows:</p> <div class="highlight"><pre><span></span><span class="k">macro</span> <span class="kd">public</span> <span class="kd">static</span> <span class="n">fuction</span> <span class="n">profile</span><span class="p">()</span><span class="err">:</span><span class="n">Array</span><span class="o">&lt;</span><span class="n">Field</span><span class="o">&gt;</span>
<span class="p">{</span>
    <span class="c1">// get the fields of the class</span>
    <span class="kd">var</span> fields<span class="p">:</span><span class="n">Array</span><span class="p">&lt;</span><span class="n">Field</span><span class="p">&gt;</span> <span class="o">=</span> <span class="n">Context</span><span class="p">.</span><span class="n">getBuildFields</span><span class="p">();</span>

    <span class="c1">// transform those fields</span>
    <span class="c1">// ...</span>

    <span class="c1">// return the transformed fields</span>
    <span class="k">return</span> <span class="n">fields</span><span class="p">;</span>
<span class="p">}</span>
</pre></div> <p>What this skeleton does is get an array of <a href="http://haxe.org/manual/class-field.html">fields</a> which make up the class and allow you to transform them (for example you could completely nuke a variable for release builds and create special variables for debug builds). Since we’re not adding or removing any fields, we can just loop through all of the fields and look for methods:</p> <div class="highlight"><pre><span></span><span class="k">for</span><span class="p">(</span><span class="n">field</span> <span class="k">in</span> <span class="n">fields</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// look for methods</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">field</span><span class="p">.</span><span class="n">kind</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// yup, found a method!</span>
        <span class="k">case</span> <span class="n">FFun</span><span class="p">(</span><span class="n">func</span><span class="p">):</span>
        <span class="p">{</span>
            <span class="c1">// get the name of the function</span>
            <span class="kd">var</span> methodName<span class="p">:</span><span class="n">String</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">// ignore variables and properties</span>
        <span class="k">default</span><span class="p">:</span> <span class="p">{}</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>The above skeleton finds each method in a class and grabs its name (which isn’t terribly useful on its own, obviously).</p> <h3><a href="#injecting-the-startprofile-code" aria-hidden="true" class="anchor" id="headerinjecting-the-startprofile-code"></a>Injecting the <code>startProfile</code> Code</h3> <p>Since all we need for the <code>startProfile</code> code is for it to be prepended to the function definition, we can redefine the function using a macro:</p> <div class="highlight"><pre><span></span><span class="c1">// yup, found a method!</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">FFun</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="c1">// get the name of the method</span>
    <span class="kd">var</span> methodName<span class="p">:</span><span class="n">String</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>

    <span class="c1">// prepend the start code to the function</span>
    <span class="n">func</span><span class="p">.</span><span class="n">expr</span> <span class="o">=</span> <span class="k">macro</span> <span class="p">{</span>
        <span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="n">$v</span> <span class="p">{</span> <span class="n">clsName</span> <span class="p">},</span> <span class="n">$v</span> <span class="p">{</span> <span class="n">methodName</span> <span class="p">}</span> <span class="p">);</span>
        <span class="n">$</span> <span class="p">{</span> <span class="n">func</span><span class="p">.</span><span class="n">expr</span> <span class="p">};</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div> <p>There’s a couple things going on here that need explaining. Firstly, the <code>macro</code> statement: using the <code>macro</code> statement before an expression is called “<a href="http://haxe.org/manual/macro-reification.html">reification</a>”, which is a fancy way of saying that the expression will be compiled into code. The expression can be any valid Haxe code, and within that expression you can use a variety of “<a href="http://haxe.org/manual/macro-reification-expression.html">escapes</a>” (think using a <code>\&quot;</code> in a string to escape a quote character.) In fact, the <code>$v{clsName}</code> and <code>$v{methodName}</code> shown above are examples of those escapes which will get replaced by the values of the <code>clsName</code> and <code>methodName</code> variables. Thus, the macro expression</p> <div class="highlight"><pre><span></span><span class="k">macro</span> <span class="p">{</span> <span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="n">$v</span><span class="p">{</span><span class="n">clsName</span><span class="p">},</span> <span class="n">$v</span><span class="p">{</span><span class="n">methodName</span><span class="p">});</span> <span class="p">}</span>
</pre></div> <p>will be converted at compile-time to the following:</p> <div class="highlight"><pre><span></span><span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="s2">&quot;exampleClass&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span>
</pre></div> <p>(assuming of course that <code>clsName == &quot;exampleClass&quot;</code> and <code>methodName == &quot;example&quot;</code>).</p> <p>Similarly, the <code>${func.expr};</code> line will get replaced by the original function expression, so if the function was originally defined as:</p> <div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">example</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">Bool</span><span class="p">):</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">39</span><span class="p">;</span>
<span class="p">}</span>
</pre></div> <p>It will now be defined as:</p> <div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">example</span><span class="p">(</span><span class="n">x</span><span class="p">:</span><span class="n">Bool</span><span class="p">):</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="s2">&quot;exampleClass&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="k">if</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
            <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
        <span class="k">return</span> <span class="mi">39</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <h3><a href="#injecting-the-endprofile-code" aria-hidden="true" class="anchor" id="headerinjecting-the-endprofile-code"></a>Injecting the <code>endProfile</code> Code</h3> <p>Injecting the <code>endProfile</code> code is a little bit more complicated than simply prepending (or in the “end” case: appending) a statement as we did for the <code>startProfile</code> code, though the principle is largely the same. The difference is that now we have to loop through the remaining expressions and replace return expressions by the special <code>endProfile</code> block we defined earlier. However this involves more than simply iterating through the expressions—some expressions within the function will more than likely be blocks, or if statements, or some other encapsulating expression that we will need to step into to search for a return statement. This is a perfect candidate for <a href="http://en.wikipedia.org/wiki/Recursion">recursion</a>. To perform this recursive search, we will create a function called <code>replaceExpressionReturn</code> (I’m terrible at names, I get it). It will be called to replace the entire function’s expression as such:</p> <div class="highlight"><pre><span></span><span class="c1">// yup, found a method!</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">FFun</span><span class="p">(</span><span class="n">func</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="c1">// get the name of the method</span>
    <span class="kd">var</span> methodName<span class="p">:</span><span class="n">String</span> <span class="o">=</span> <span class="n">field</span><span class="p">.</span><span class="n">name</span><span class="p">;</span>

    <span class="c1">// prepend the start code to the function</span>
    <span class="n">func</span><span class="p">.</span><span class="n">expr</span> <span class="o">=</span> <span class="k">macro</span> <span class="p">{</span>
        <span class="n">Profiler</span><span class="p">.</span><span class="n">startProfile</span><span class="p">(</span><span class="n">$v</span> <span class="p">{</span> <span class="n">clsName</span> <span class="p">},</span> <span class="n">$v</span> <span class="p">{</span> <span class="n">methodName</span> <span class="p">}</span> <span class="p">);</span>
        <span class="n">$</span> <span class="p">{</span> <span class="n">func</span><span class="p">.</span><span class="n">expr</span> <span class="p">};</span>
    <span class="p">};</span>

    <span class="c1">// start the recursive expression transformation</span>
    <span class="n">func</span><span class="p">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">func</span><span class="p">.</span><span class="n">expr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div> <h4><a href="#recursively-searching-an-expression-for-return-statements" aria-hidden="true" class="anchor" id="headerrecursively-searching-an-expression-for-return-statements"></a>Recursively Searching An Expression for Return Statements</h4> <p>Now that we have our function signature down we can start actually defining the function:</p> <div class="highlight"><pre><span></span><span class="cm">/**</span>
<span class="cm"> * This is a recursive function which will tunnel into a function&#39;s expressions and replace any</span>
<span class="cm"> * occurrances of a return expression with a custom profiling return expressions</span>
<span class="cm"> * @param    clsName    a string representing the host class name</span>
<span class="cm"> * @param    methodName a string representing the method name</span>
<span class="cm"> * @param    expr    the current expression to operate on (starting at the function definition)</span>
<span class="cm"> * @return    the transformed expression</span>
<span class="cm"> */</span>
<span class="kd">private</span> <span class="kd">static</span> <span class="kd">function</span> <span class="nf">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">methodName</span><span class="p">:</span><span class="n">String</span><span class="p">,</span> <span class="n">expr</span><span class="p">:</span><span class="n">Expr</span><span class="p">):</span><span class="n">Expr</span>
<span class="p">{</span>
    <span class="c1">// look for specific expression types</span>
    <span class="k">switch</span><span class="p">(</span><span class="n">expr</span><span class="p">.</span><span class="n">expr</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// our beloved return expression</span>
        <span class="k">case</span> <span class="n">EReturn</span><span class="p">(</span><span class="n">retExpr</span><span class="p">):</span>
        <span class="p">{</span>
            <span class="c1">// TODO: transform the return expression!</span>
        <span class="p">}</span>

        <span class="c1">// don&#39;t transform anything else</span>
        <span class="k">default</span><span class="p">:</span> <span class="p">{</span> <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">expr</span><span class="p">;</span>
<span class="p">}</span>
</pre></div> <p>So far this function is very basic, and doesn’t actually transform the expression at all. All we do is check the type of the current expression that we’re investigation (<code>expr</code>), and branch the macro depending on that type. So far all we’re looking for is a return statement. Once we’ve found a return statement, we can create a new expression using our profiling block and use it to replace the return expression:</p> <div class="highlight"><pre><span></span><span class="err">c</span><span class="n">ase</span> <span class="n">EReturn</span><span class="p">(</span><span class="n">retExpr</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="c1">// we found a return expression, change it to our special block!</span>
    <span class="k">return</span> <span class="k">macro</span> <span class="p">{</span>
        <span class="kd">var</span> ___tempProfilingReturnValue <span class="o">=</span> <span class="n">$</span><span class="p">{</span><span class="n">retExpr</span><span class="p">};</span>
        <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="n">$v</span> <span class="p">{</span> <span class="n">clsName</span> <span class="p">},</span> <span class="n">$v</span> <span class="p">{</span> <span class="n">methodName</span> <span class="p">}</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">___tempProfilingReturnValue</span><span class="p">;</span>
    <span class="p">};</span>
<span class="p">}</span>
</pre></div> <p>Now, same as before, we’re constructing a <code>macro</code> to use as the expression. This time, the macro is three lines of code (rather than a single line as before), but that doesn’t really matter. Assuming you understood what happened before with the <code>startProfile</code> code, this should all be fairly self-explanatory. The only real “new” thing is the use of <code>${retExpr}</code>, which is simply an escape that will print out the old return expression, so something like:</p> <div class="highlight"><pre><span></span><span class="k">return</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">PI</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
</pre></div> <p>would be transformed into:</p> <div class="highlight"><pre><span></span><span class="p">{</span>
    <span class="kd">var</span> ___tempProfilingReturnValue <span class="o">=</span> <span class="mi">5</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">sin</span><span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">Math</span><span class="p">.</span><span class="n">PI</span> <span class="o">*</span> <span class="n">f</span><span class="p">)</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
    <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="s2">&quot;exampleClass&quot;</span><span class="p">,</span> <span class="s2">&quot;exampleMethod&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">___tempProfilingReturnValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div> <p>If you run this code as-is, you’ll note that the <code>endProfile</code> code will never be injected, even if you have a function that <em>only</em> has a return statement:</p> <div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">example</span><span class="p">():</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
<span class="p">}</span>
</pre></div> <p>Since the <code>startProfile</code> code has already been injected, the above would currently transform into:</p> <div class="highlight"><pre><span></span><span class="kd">function</span> <span class="nf">example</span><span class="p">():</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="n">Profiler</span><span class="p">.</span><span class="n">profile</span><span class="p">(</span><span class="s2">&quot;exampleClass&quot;</span><span class="p">,</span> <span class="s2">&quot;example&quot;</span><span class="p">);</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="mi">42</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>Why is this? We check for a return expression and when we find it, we change it? As it turns out, the first expression in the function definition would actually be a <a href="http://haxe.org/manual/expression-block.html">Block</a> (an <a href="http://api.haxe.org/haxe/macro/ExprDef.html#EBlock">EBlock</a> <a href="http://api.haxe.org/haxe/macro/ExprDef.html">ExprDef</a>). So, we should handle that case:</p> <div class="highlight"><pre><span></span><span class="c1">// a block ({})</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">EBlock</span><span class="p">(</span><span class="n">blockExprs</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="kd">var</span> i <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">blockExprs</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">blockExprs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">blockExprs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">macro</span> <span class="n">$b</span> <span class="p">{</span> <span class="n">blockExprs</span> <span class="p">};</span>
<span class="p">}</span>
</pre></div> <p>According to the API documentation, a block is represented by <a href="http://api.haxe.org/haxe/macro/ExprDef.html#EBlock">EBlock</a>, which is basically just <code>Array&lt;Expr&gt;</code>. Thus, we can iterate over the each expression in the block and transform it using our recursive function. Once all the expressions in the block are processed, we can return a macro representing the block, using the <code>$b{}</code> <a href="http://haxe.org/manual/macro-reification-expression.html">escape pattern</a> to convert the array of expressions into a block expression.</p> <p>Filling out the block expression case helps us solve our problem above, but we still have several other cases when a <code>return</code> expression could be nested away. Namely, this is a problem in the following classes:</p> <ul> <li><a href="http://haxe.org/manual/expression-block.html">Blocks</a>: <a href="http://api.haxe.org/haxe/macro/ExprDef.html#EBlock">EBlock</a></li> <li><a href="http://haxe.org/manual/expression-for.html">For loops</a>: <a href="http://api.haxe.org/haxe/macro/ExprDef.html#EFor">EFor</a></li> <li><a href="http://haxe.org/manual/expression-while.html">While loops</a> / <a href="http://haxe.org/manual/expression-do-while.html">Do-While loops</a>: <a href="http://api.haxe.org/haxe/macro/ExprDef.html#EWhile">EWhile</a></li> <li><a href="http://haxe.org/manual/expression-if.html">Ifs</a>: <a href="http://api.haxe.org/haxe/macro/ExprDef.html#EIf">EIf</a></li> <li><a href="http://haxe.org/manual/expression-switch.html">Switches</a>: <a href="http://api.haxe.org/haxe/macro/ExprDef.html#ESwitch">ESwitch</a></li> <li><a href="http://haxe.org/manual/expression-try-catch.html">Try / Catches</a>: <a href="http://api.haxe.org/haxe/macro/ExprDef.html#ETry">ETry</a></li> </ul> <p>All that’s left to do to deal with these situations is to handle their cases and recursively call the function on each expression found within each situation. I won’t go through the details of doing this for every sitatution as it’s all pretty much the same as the block case. I’ll just list how I handled those cases here:</p> <div class="highlight"><pre><span></span><span class="c1">// a block ({})</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">EBlock</span><span class="p">(</span><span class="n">blockExprs</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="kd">var</span> i <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">blockExprs</span><span class="p">.</span><span class="n">length</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">blockExprs</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">blockExprs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
        <span class="n">i</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">macro</span> <span class="n">$b</span> <span class="p">{</span> <span class="n">blockExprs</span> <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// a for loop</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">EFor</span><span class="p">(</span><span class="n">it</span><span class="p">,</span> <span class="n">forExpr</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="n">forExpr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">forExpr</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">macro</span>  <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">$</span> <span class="p">{</span> <span class="n">it</span> <span class="p">}</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">$</span> <span class="p">{</span> <span class="n">forExpr</span> <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// a while loop</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">EWhile</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">whileExpr</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="n">whileExpr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">whileExpr</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">macro</span>  <span class="p">{</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">$</span> <span class="p">{</span> <span class="n">cond</span> <span class="p">}</span> <span class="p">)</span>
        <span class="p">{</span>
            <span class="n">$</span> <span class="p">{</span> <span class="n">whileExpr</span> <span class="p">};</span>
        <span class="p">}</span>
    <span class="p">};</span>
<span class="p">}</span>

<span class="c1">// an if statement</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">EIf</span><span class="p">(</span><span class="n">cond</span><span class="p">,</span> <span class="n">ifExpr</span><span class="p">,</span> <span class="n">elseExpr</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="n">ifExpr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">ifExpr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">elseExpr</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
        <span class="n">elseExpr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">elseExpr</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">elseExpr</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">macro</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">$</span> <span class="p">{</span> <span class="n">cond</span> <span class="p">}</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">$</span> <span class="p">{</span> <span class="n">ifExpr</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">macro</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">$</span> <span class="p">{</span> <span class="n">cond</span> <span class="p">}</span> <span class="p">)</span>
            <span class="p">{</span>
                <span class="n">$</span> <span class="p">{</span> <span class="n">ifExpr</span> <span class="p">};</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="n">$</span> <span class="p">{</span> <span class="n">elseExpr</span> <span class="p">};</span>
            <span class="p">}</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// a switch statement</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">ESwitch</span><span class="p">(</span><span class="n">switchExpr</span><span class="p">,</span> <span class="n">cases</span><span class="p">,</span> <span class="n">defaultExpr</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cas</span> <span class="k">in</span> <span class="n">cases</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cas</span><span class="p">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">cas</span><span class="p">.</span><span class="n">expr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span><span class="p">(</span><span class="n">defaultExpr</span> <span class="o">!=</span> <span class="kc">null</span><span class="p">)</span>
        <span class="n">defaultExpr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">defaultExpr</span><span class="p">);</span>
    <span class="k">return</span> <span class="k">macro</span> <span class="p">{</span>
        <span class="n">$expr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// try / catch statements</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">ETry</span><span class="p">(</span><span class="n">tryExpr</span><span class="p">,</span> <span class="n">catches</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="n">tryExpr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">tryExpr</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">cat</span> <span class="k">in</span> <span class="n">catches</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">cat</span><span class="p">.</span><span class="n">expr</span> <span class="o">=</span> <span class="n">replaceExpressionsReturn</span><span class="p">(</span><span class="n">clsName</span><span class="p">,</span> <span class="n">methodName</span><span class="p">,</span> <span class="n">cat</span><span class="p">.</span><span class="n">expr</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="k">macro</span> <span class="p">{</span>
        <span class="n">$expr</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>Now we’re most of the way—just two relatively small things stand in our way:</p> <ol> <li>Void functions with a return statement but no expression, ie <code>return;</code>. <ul> <li>This will cause an error the way things are currently handled as we don’t account for the fact that <code>retExpr</code> may be null.</li> </ul> </li> <li>Void functions without a return statement <ul> <li>This is a problem because we’re only modifying return statements. If there isn’t a return statement to modify, our <code>endProfile</code> code will never get called.</li> </ul> </li> </ol> <h4><a href="#dealing-with-empty-return-statements" aria-hidden="true" class="anchor" id="headerdealing-with-empty-return-statements"></a>Dealing With Empty Return Statements</h4> <p>This is a relatively easy fix. All we have to do is check to see if <code>retExpr</code> is <code>null</code>, and if so, don’t deal with returning anything fancy. The <code>EReturn</code> handling case can be modified as such to fix the problem:</p> <div class="highlight"><pre><span></span><span class="c1">// our beloved return expression</span>
<span class="err">c</span><span class="n">ase</span> <span class="n">EReturn</span><span class="p">(</span><span class="n">retExpr</span><span class="p">)</span><span class="err">:</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">retExpr</span> <span class="o">==</span> <span class="kc">null</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">macro</span> <span class="p">{</span>
            <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="n">$v</span> <span class="p">{</span> <span class="n">clsName</span> <span class="p">},</span> <span class="n">$v</span> <span class="p">{</span> <span class="n">methodName</span> <span class="p">}</span> <span class="p">);</span>
            <span class="k">return</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">macro</span> <span class="p">{</span>
            <span class="kd">var</span> ___tempProfilingReturnValue <span class="o">=</span> <span class="n">$</span><span class="p">{</span><span class="n">retExpr</span><span class="p">};</span>
            <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="n">$v</span> <span class="p">{</span> <span class="n">clsName</span> <span class="p">},</span> <span class="n">$v</span> <span class="p">{</span> <span class="n">methodName</span> <span class="p">}</span> <span class="p">);</span>
            <span class="k">return</span> <span class="n">___tempProfilingReturnValue</span><span class="p">;</span>
        <span class="p">};</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <h4><a href="#dealing-with-void-functions-without-a-return-statement" aria-hidden="true" class="anchor" id="headerdealing-with-void-functions-without-a-return-statement"></a>Dealing With Void Functions Without A Return Statement</h4> <p>This is going to be a little bit trickier. After a decent amount of “guess-and-test”, I came up with a relatively simple, if tedious, solution: add a variable which keeps track of whether or not the most recently processed statement was a return statement or not. If we finish transforming the function and the most recent statement wasn’t a return statement, then add the <code>endProfile</code> code; otherwise, do nothing.</p> <p>I implemented the variable as a static class-level variable (<code>var lastWasReturn:Bool = false;</code>). In each of the <code>replaceExpressionsReturn</code> function’s cases I then set this variable to false, with the exception of the return case. Then, in the main <code>profile()</code> function I add the following statement:</p> <div class="highlight"><pre><span></span><span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">lastWasReturn</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">func</span><span class="p">.</span><span class="n">expr</span> <span class="o">=</span> <span class="k">macro</span> <span class="p">{</span>
        <span class="n">$</span> <span class="p">{</span> <span class="n">func</span><span class="p">.</span><span class="n">expr</span> <span class="p">};</span>
        <span class="n">Profiler</span><span class="p">.</span><span class="n">endProfile</span><span class="p">(</span><span class="n">$v</span> <span class="p">{</span> <span class="n">clsName</span> <span class="p">},</span> <span class="n">$v</span> <span class="p">{</span> <span class="n">methodName</span> <span class="p">}</span> <span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div> <p>I know that describing things this way isn’t ideal, but instead of essentially directly copying all the code over again, I will just let you browse the entire working project as a Gist: <a href="https://gist.github.com/hamaluik/412e2109a5f5fbcf12e1">https://gist.github.com/hamaluik/412e2109a5f5fbcf12e1</a>.</p> <h2><a href="#caveats-with-this-profiler" aria-hidden="true" class="anchor" id="headercaveats-with-this-profiler"></a>Caveats With This Profiler</h2> <p>There are a couple issues with this profiler that are still outstanding, namely:</p> <ul> <li>It only deals with class-level functions</li> <li>It provides no mechanism for investigating <em>parts</em> of a function (though I would argue that you shouldn’t have a function with multiple “parts” anyway)</li> <li>It doesn’t profile the getters and setters of properties (which should be fairly insubstantial anyway)</li> <li>It relies on the <code>Sys.cpuTime()</code> function to calculate run time, which for many fast functions will return <code>0</code> (even when it was’t truly non-zero) due to the resolution of the function. I’m not sure how to get higher resolution timing information in Haxe yet.</li> </ul> <h2><a href="#conclusions" aria-hidden="true" class="anchor" id="headerconclusions"></a>Conclusions</h2> <p>Hopefully this gave a decent introduction to macros in Haxe (or at least, <em>build</em> macros!) while creating a handy tool to use in future projects. If you have any questions, comments, or concerns, I’d love to hear from you in the comments. And thanks again to <a href="https://github.com/ousado">ousado</a> and the <a href="http://webchat.freenode.net/?channels=haxe">Haxe IRC</a> for helping me to learn the black magic that is Haxe macros!</p> <script src="/ruffle/ruffle.js"></script> </article> <footer> <span>© 2021 <a href="https://hamaluik.ca">Kenton Hamaluik</a></span> <span><a class="has-icon" href="https://blog.hamaluik.ca/feed.rss"><svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 256 256"><rect width="256" height="256" fill="none"></rect><path d="M48,144a64,64,0,0,1,64,64" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"></path><path d="M48,96A112,112,0,0,1,160,208" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"></path><path d="M48,48A160,160,0,0,1,208,208" fill="none" stroke="currentColor" stroke-linecap="round" stroke-linejoin="round" stroke-width="16"></path><circle cx="52" cy="204" r="12"></circle></svg> Subscribe</a></span> </footer> </body> </html>