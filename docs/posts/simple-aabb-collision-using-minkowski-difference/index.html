<!DOCTYPE html><html lang="en-CA"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Simple AABB Collision Detection Using the Minkowski Difference</title><link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400,400i,700|Eczar:700|Source+Code+Pro:400,400i&display=swap" rel="stylesheet"><link href="/style.css" rel="stylesheet"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"> <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#bf616a"><meta name="msapplication-TileColor" content="#bf616a"><meta name="theme-color" content="#bf616a"> <meta property="og:title" content="Simple AABB Collision Detection Using the Minkowski Difference"/><meta property="og:url" content="http://blog.hamaluik.ca/posts/simple-aabb-collision-using-minkowski-difference/"/><meta property="og:image" content="https://og-image.now.sh/Simple%20AABB%20Collision%20Detection%20Using%20the%20Minkowski%20Difference.png?theme=light&md=0&fontSize=75px&images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fhyper-color-logo.svg&widths=350&heights=350"/><meta property="og:description" content="Since I’ve started on an adventure to start creating my games with Haxe and OpenFL, I found myself in need of some collision detection. I don’t really need anything as fancy or extensive as Nape, and although the HxCollision library is a pretty solid Separating Axis Theorem implementation, it doesn’t deal with swept-collisions, which is a bit of an issue for games (without swept collisions, any lag spikes can easily cause objects to pass right through objects!)."/><meta property="og:type" content="article"/><meta property="og:locale" content="en_CA"/><meta property="og:site_name" content="Kenton Hamaluik"/><meta property="article:published_time" content=" 2014-10-04T23:47:13+00:00 "/><meta property="article:author" content="http://blog.hamaluik.ca/"/><meta property="article:tag" content="Haxe"/><meta property="article:tag" content="Math"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image:alt" content="Simple AABB Collision Detection Using the Minkowski Difference"/></head><body><header><h1><a href="https://blog.hamaluik.ca/">Kenton Hamaluik</a></h1></header><article><header><h1>Simple AABB Collision Detection Using the Minkowski Difference <time datetime='2014-10-04T23:47:13+00:00'>(2014-10-04)</time></h1></header><p>Since I’ve started on an adventure to start creating my games with <a href="http://haxe.org/">Haxe</a> and <a href="http://www.openfl.org/">OpenFL</a>, I found myself in need of some collision detection. I don’t really need anything as fancy or extensive as <a href="http://napephys.com/">Nape</a>, and although the <a href="https://github.com/underscorediscovery/hxcollision">HxCollision</a> library is a pretty solid Separating Axis Theorem implementation, it doesn’t deal with swept-collisions, which is a bit of an issue for games (without swept collisions, any lag spikes can easily cause objects to pass right through objects!).</p><p>With some simple requirements in mind, I started Googling, and came across a method of using <a href="http://en.wikipedia.org/wiki/Minkowski_addition">Minkowski addition</a> to detect collisions. It turns out this method is <em>super</em> fast and <em>very</em> easy to compute for axis-aligned bounding-boxes (AABBs), which is all I’m going to focus on for now. This point is also only going to focus on discrete detection (whether or not an AABB is penetrating another object, regardless of velocity). I’ll do another post on using this method with swept collisions when I have that sorted out.</p><p>When you first read about <a href="http://twistedoakstudios.com/blog/Post554_minkowski-sums-and-differences">Minkowski sums and differences</a>, it can become very confusing very quickly (even if you are adept at math!). Luckily for us, the Minkowksi difference for two AABBs is itself an AABB, calculated as follows (assuming positive y is towards the bottom of the screen):</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>AABB_{left}^{MD} = AABB_{left}^A - AABB_{right}<sup>B<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>AABB_{top}</sup>{MD} = AABB_{top}^A - AABB_{bottom}<sup>B<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>AABB_{width}</sup>{MD} = AABB_{width}^A + AABB_{width}<sup>B<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>AABB_{height}</sup>{MD} = AABB_{height}^A + AABB_{height}^B<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></p><p>This tells us that when you compute the Minkowski difference of two AABBs, not only is the result bigger (its width and height are the sum of the input widths and heights, respectively), but its position is in some new weird location. Due to some fancy math that I won’t get into here, it turns out that if the resulting Minkowkski-differenced AABB is encompasses the origin—<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mn>0</mn><mo separator="true">,</mo><mn>0</mn><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(0, 0)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord">0</span><span class="mpunct">,</span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord">0</span><span class="mclose">)</span></span></span></span>—the two input AABBs are colliding! Thankfully, this is incredibly easy to calculate:</p><div class="highlight"><pre><span></span><span class="kd">var</span> boundsPoint<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="kc">null</span><span class="p">;</span>
<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="n">md</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="n">md</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="n">md</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">colliding</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p>You can see a demo showing this off below:</p><figure><embed src="/imagessimple-aabb-collision-using-minkowski-difference/detect.swf" width="500" height="500"><figcaption>Move your mouse around to move the small box. When it's colliding with the larger box, it turns green! The blue box is actually the resulting Minkowski difference AABB (notice how when the box collides, the Minkowski AABB covers the origin).</figcaption></figure><p>Here’s the code that drives an AABB class:</p><div class="highlight"><pre><span></span><span class="kn">package</span> <span class="p">;</span>

<span class="cm">/**</span>
<span class="cm"> * ...</span>
<span class="cm"> * @author Kenton Hamaluik</span>
<span class="cm"> */</span>
<span class="kd">class</span> <span class="n">AABB</span>
<span class="p">{</span>
    <span class="kd">public</span> <span class="kd">var</span> center<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">();</span>
    <span class="kd">public</span> <span class="kd">var</span> extents<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">();</span>
    <span class="kd">public</span> <span class="kd">var</span> min<span class="p">(</span><span class="k">get</span><span class="p">,</span> <span class="k">never</span><span class="p">):</span><span class="n">Vector</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">get_min</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">extents</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">extents</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="kd">var</span> max<span class="p">(</span><span class="k">get</span><span class="p">,</span> <span class="k">never</span><span class="p">):</span><span class="n">Vector</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">get_max</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">center</span><span class="p">.</span><span class="n">x</span> <span class="o">+</span> <span class="n">extents</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">center</span><span class="p">.</span><span class="n">y</span> <span class="o">+</span> <span class="n">extents</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="kd">public</span> <span class="kd">var</span> size<span class="p">(</span><span class="k">get</span><span class="p">,</span> <span class="k">never</span><span class="p">):</span><span class="n">Vector</span><span class="p">;</span>
    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">get_size</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">extents</span><span class="p">.</span><span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">,</span> <span class="n">extents</span><span class="p">.</span><span class="n">y</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">new</span><span class="p">(</span><span class="n">center</span><span class="p">:</span><span class="n">Vector</span><span class="p">,</span> <span class="n">extents</span><span class="p">:</span><span class="n">Vector</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">this</span><span class="p">.</span><span class="n">center</span> <span class="o">=</span> <span class="n">center</span><span class="p">;</span>
        <span class="k">this</span><span class="p">.</span><span class="n">extents</span> <span class="o">=</span> <span class="n">extents</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">public</span> <span class="kd">function</span> <span class="nf">minkowskiDifference</span><span class="p">(</span><span class="n">other</span><span class="p">:</span><span class="n">AABB</span><span class="p">):</span><span class="n">AABB</span>
    <span class="p">{</span>
        <span class="kd">var</span> topLeft<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">min</span> <span class="o">-</span> <span class="n">other</span><span class="p">.</span><span class="n">max</span><span class="p">;</span>
        <span class="kd">var</span> fullSize<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">size</span> <span class="o">+</span> <span class="n">other</span><span class="p">.</span><span class="n">size</span><span class="p">;</span>
        <span class="k">return</span> <span class="k">new</span> <span class="n">AABB</span><span class="p">(</span><span class="n">topLeft</span> <span class="o">+</span> <span class="p">(</span><span class="n">fullSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">),</span> <span class="n">fullSize</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div><p>We can take this a step further by calculating the penetration vector of the two AABBs. Quite conveniently, the penetration vector is simply the minimum distance from the origin to the Minkowski-differenced resultant AABB, as shown below:</p><figure><img src="/imagessimple-aabb-collision-using-minkowski-difference/penetration_vector.png"><figcaption>The penetration vector is the vector that you can apply to one AABB to make sure it leaves the other.</figcaption></figure><p>The penetration vector can be calculated like so:</p><div class="highlight"><pre><span></span><span class="c1">// (in the AABB class)</span>
<span class="kd">public</span> <span class="kd">function</span> <span class="nf">closestPointOnBoundsToPoint</span><span class="p">(</span><span class="n">point</span><span class="p">:</span><span class="n">Vector</span><span class="p">):</span><span class="n">Vector</span>
<span class="p">{</span>
    <span class="kd">var</span> minDist<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
    <span class="kd">var</span> boundsPoint<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">minDist</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">);</span>
        <span class="n">boundsPoint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">minDist</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="n">boundsPoint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">minDist</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">minDist</span> <span class="o">=</span> <span class="n">Math</span><span class="p">.</span><span class="n">abs</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">y</span> <span class="o">-</span> <span class="n">point</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
        <span class="n">boundsPoint</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">point</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">boundsPoint</span><span class="p">;</span>
<span class="p">}</span>

<span class="o">...</span>

<span class="c1">// (elsewhere)</span>
<span class="kd">var</span> penetrationVector<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">md</span><span class="p">.</span><span class="n">closestPointOnBoundsToPoint</span><span class="p">(</span><span class="n">Vector</span><span class="p">.</span><span class="n">zero</span><span class="p">);</span>
</pre></div><p>Once we have the penetration vector, keeping the movable AABB out of the large static one is trivial:</p><div class="highlight"><pre><span></span><span class="n">boxA</span><span class="p">.</span><span class="n">center</span> <span class="o">+=</span> <span class="n">penetrationVector</span><span class="p">;</span>
</pre></div><p>And with just those few small calculations, we can achieve this:</p><figure><embed src="/imagessimple-aabb-collision-using-minkowski-difference/no_penetrate.swf" width="500" height="500"><figcaption>By applying the penetration vector to the small box, we can prevent it from overlapping with the larger one.</figcaption></figure><p><a href="https://gist.github.com/hamaluik/048d24c5d3ce154316f3">I’ve posted the source</a> for the demos shown here so you can see all the machinery in place. That said, it’s still super simple! Join me next time when I explore using this technique to do <strong>continuous</strong> collision detection between two moving AABBs!</p></article><footer><span>© 2020 <a href="https://hamaluik.ca">Kenton Hamaluik</a></span></footer></body></html>