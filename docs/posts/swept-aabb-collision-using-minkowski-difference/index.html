<!DOCTYPE html><html lang="en-CA"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1"><title>Swept AABB Collision Detection Using the Minkowski Difference</title><link href="https://fonts.googleapis.com/css?family=Crimson+Pro:400,400i,700|Eczar:700|Source+Code+Pro:400,400i&display=swap" rel="stylesheet"><link href="/style.css?d=20200104" rel="stylesheet"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.11.1/dist/katex.min.css" integrity="sha384-zB1R0rpPzHqg7Kpt0Aljp8JPLqbXI3bhnPWROx27a9N0Ll6ZP/+DiW/UqRcLbRjq" crossorigin="anonymous"><link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png"><link rel="manifest" href="/site.webmanifest"><link rel="mask-icon" href="/safari-pinned-tab.svg" color="#ff5555"><meta name="msapplication-TileColor" content="#ff5555"><meta name="theme-color" content="#ff5555"><meta property="og:title" content="Swept AABB Collision Detection Using the Minkowski Difference"/><meta property="og:url" content="http://blog.hamaluik.ca/posts/swept-aabb-collision-using-minkowski-difference/"/><meta property="og:image" content="https://og-image.now.sh/Swept%20AABB%20Collision%20Detection%20Using%20the%20Minkowski%20Difference.png?theme=light&md=0&fontSize=75px&images=https%3A%2F%2Fassets.zeit.co%2Fimage%2Fupload%2Ffront%2Fassets%2Fdesign%2Fhyper-color-logo.svg&widths=350&heights=350"/><meta property="og:description" content="Continuing on from yesterday’s post where I explored detecting discrete collisions using Minkowski differences, today I’m going to talk about detecting continuous collisions using Minkowski differences (again, focusing solely on axis-aligned bounding boxes). Continuous collision detection is essential in any game where you have fast-moving objects and&#x2F;or low frame rates. It adds slightly more complexity to the discrete collision detection algorithm, but the advantages far outweigh the costs in this case!"/><meta property="og:type" content="article"/><meta property="og:locale" content="en_CA"/><meta property="og:site_name" content="Kenton Hamaluik"/><meta property="article:published_time" content=" 2014-10-05T23:47:13+00:00 "/><meta property="article:author" content="http://blog.hamaluik.ca/"/><meta property="article:tag" content="Haxe"/><meta property="article:tag" content="Math"/><meta name="twitter:card" content="summary_large_image"/><meta name="twitter:image:alt" content="Swept AABB Collision Detection Using the Minkowski Difference"/></head><body><header><h1><a href="https://blog.hamaluik.ca/">Kenton Hamaluik</a></h1></header><article><header><h1>Swept AABB Collision Detection Using the Minkowski Difference <time datetime='2014-10-05T23:47:13+00:00'>(2014-10-05)</time></h1></header><p>Continuing on from <a href="http://blog.hamaluik.ca/posts/simple-aabb-collision-using-the-minkowski-difference/">yesterday’s post</a> where I explored detecting discrete collisions using Minkowski differences, today I’m going to talk about detecting <strong>continuous</strong> collisions using Minkowski differences (again, focusing solely on axis-aligned bounding boxes). Continuous collision detection is essential in any game where you have fast-moving objects and/or low frame rates. It adds slightly more complexity to the discrete collision detection algorithm, but the advantages far outweigh the costs in this case!</p><p>If you aren’t already familiar with performing discrete collision detection using Minkowski differences, I suggest you <a href="http://blog.hamaluik.ca/posts/simple-aabb-collision-using-the-minkowski-difference/">read up on that now</a>—what I’m talking about here is an extension of that work. Probably the biggest reason to use swept/continuous collision detection rather than discrete detection is to prevent what is called <em>tunneling</em>, which is shown below.</p><figure><img src="/images/swept-aabb-collision-minkowski/tunneling.png"><figcaption>Since we're only solving physics at discrete time points, if an object is moving fast enough (or if the time between discrete points is large enough), said object will jump right "through" an obstacle without a collision ever being detected.</figcaption></figure><p>The first thing we need to know about doing continuous collision detection using Minkowski differences is that the technique <em>doesn’t</em> work if the objects are already colliding (i.e., the resultant Minkowski AABB contains the origin). This isn’t too bad however, as if the origin <em>is</em> in the AABB, we can just do discrete collision detection to push the two objects apart. So if the Minkowski AABB cannot contain the origin, then that means that the Minkowski AABB must be located at some distance from the origin:</p><figure><img src="/images/swept-aabb-collision-minkowski/origin_outside.png"></figure><p>We also know that if the Minkowski AABB <strong>ever</strong> contains the origin, then the two objects are colliding. If we are somehow able to construct a vector to move the Minkowski AABB such that it covers the origin, we know that the two objects will collide. If one of the objects were completely static (i.e., not moving), this vector would be the distance moved during the current frame by the moving box, i.e.:</p><div class="highlight"><pre><span></span><span class="kd">var</span> movementThisFrame<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</pre></div><p>However, since in this scenario <strong>both</strong> AABBs could be moving, we must make use of the <a href="http://en.wikipedia.org/wiki/Relative_velocity"><em>relative</em> velocity</a> between the two AABBs. The relative velocity between two objects refers to the <strong>difference</strong> in their velocities:</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>\vec{v}_{B/A} = \vec{v}_B - \vec{v}_A<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></p><p>In a typical world view, each box has its own velocity and is moving of its own accord:</p><figure><img src="/images/swept-aabb-collision-minkowski/world_velocity.png"></figure><p>However, if you were to pretend for a moment that the red box is a car in a featureless black box and you were looking at the blue box, you would see its motion <em>relative</em> to you, as if your car were perfectly still and the blue box was the only thing moving:</p><figure><img src="/images/swept-aabb-collision-minkowski/velocity_b_relative_to_a.png"></figure><p>Conversely, if you were in the blue box looking at the red one, your perception would be different:</p><figure><img src="/images/swept-aabb-collision-minkowski/velocity_a_relative_to_b.png"></figure><p>So; relative velocity—simple. But what does it have to do with continuous collision detection? Well, since the Minkowski AABB is the Minkowski <em>difference</em> of our two AABBs, it would make sense that the vector which moves the Minkowski AABB over the origin is the <em>difference</em> (relative velocity) of our two AABB’s velocities:</p><div class="highlight"><pre><span></span><span class="kd">var</span> relativeMotion<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">boxB</span><span class="p">.</span><span class="n">velocity</span> <span class="o">-</span> <span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</pre></div><p>However note that we aren’t calculating this vector based on how much we need to move the Minkowski AABB to cover the origin—we’re calculating it based on the current velocities of each of the input boxes. Thus, there is <em>no</em> guarantee that this vector will cause the Minkowski AABB to cover the origin and cause the AABBs to collide. However, <strong>if it does</strong>, we know that the two objects will collide during this frame! Kinda sneaky, eh?</p><figure><img src="/images/swept-aabb-collision-minkowski/relativeMotion_noCollide.png"><figcaption>If moving the Minkowski AABB by the relative motion vector doesn't cause it to cover the origin, the objects can't collide during this frame.</figcaption></figure><figure><img src="/images/swept-aabb-collision-minkowski/relativeMotion_collide.png"><figcaption>However, if moving the Minkowski AABB by the relative motion vector <b>does</b> cause it to cover the origin, the objects <b>will</b> collide during this frame!</figcaption></figure><p>This is fine and dandy if all we want to do is check whether or not the objects <em>will</em> or <em>won’t</em> collide—but if we want to <strong>prevent</strong> those objects from colliding, we’re going to have to do things a little bit different. We’ll still use the relative velocity, but this time we’ll change the perspective:</p><div class="highlight"><pre><span></span><span class="kd">var</span> relativeMotion<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span> <span class="o">-</span> <span class="n">boxB</span><span class="p">.</span><span class="n">velocity</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
</pre></div><p>Now, we can ray-trace this relative motion vector from the origin, and see if it collides with our Minkowski AABB (see below). If it does, we get the same result as before with an added bonus—the point on the ray which first touches the AABB defines the point in time when the two objects will start colliding.</p><figure><img src="/images/swept-aabb-collision-minkowski/raytrace_nohit.png"><figcaption>If the relativeMotion ray cast from the origin <em>doesn't</em> intersect the AABB, then no collision will occur this frame.</figcaption></figure><figure><img src="/images/swept-aabb-collision-minkowski/raytrace_hit.png"><figcaption>If the relativeMotion ray cast from the origin <em>does</em> intersect the AABB, then a collision will occur at the collision point.</figcaption></figure><p>Once we have the collision point, all that’s left to do is move the AABBs only as far as that collision point and zero their velocity in the normal direction. Note that this is a lot simpler if the collision point is converted into a fractional component <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mo stretchy="false">(</mo><mi>h</mi><mo stretchy="false">)</mo></mrow><annotation encoding="application/x-tex">(h)</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:1em;vertical-align:-0.25em;"></span><span class="mopen">(</span><span class="mord mathdefault">h</span><span class="mclose">)</span></span></span></span> of the relativeMotion vector such that:</p><div><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>h\cdot\vec{d}_{B/A} = \vec{d}_{collision}<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></div><p>We can then take <span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow><mi>h</mi></mrow><annotation encoding="application/x-tex">h</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.69444em;vertical-align:0em;"></span><span class="mord mathdefault">h</span></span></span></span> to move the two boxes only as far as they can physically go (without penetrating each other):</p><p><span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span>\vec{p}_A = \vec{p}_A + \left(\vec{v}_A \cdot \Delta_t \cdot h\right)<span class="katex"><span class="katex-mathml"><math xmlns="http://www.w3.org/1998/Math/MathML"><semantics><mrow></mrow><annotation encoding="application/x-tex"></annotation></semantics></math></span><span class="katex-html" aria-hidden="true"></span></span></p><p>In code, this is easy:</p><div class="highlight"><pre><span></span><span class="kd">var</span> md<span class="p">:</span><span class="n">AABB</span> <span class="o">=</span> <span class="n">boxB</span><span class="p">.</span><span class="n">minkowskiDifference</span><span class="p">(</span><span class="n">boxA</span><span class="p">);</span>
<span class="k">if</span> <span class="p">(</span><span class="n">md</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="n">md</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">x</span> <span class="o">&gt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="n">md</span><span class="p">.</span><span class="n">min</span><span class="p">.</span><span class="n">y</span> <span class="o">&lt;=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span>
    <span class="n">md</span><span class="p">.</span><span class="n">max</span><span class="p">.</span><span class="n">y</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// normal discrete collision detection / separation code</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
    <span class="c1">// calculate the relative motion between the two boxes</span>
    <span class="kd">var</span> relativeMotion<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="p">(</span><span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span> <span class="o">-</span> <span class="n">boxB</span><span class="p">.</span><span class="n">velocity</span><span class="p">)</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>

    <span class="c1">// ray-cast the relativeMotion vector against the Minkowski AABB</span>
    <span class="kd">var</span> h<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">md</span><span class="p">.</span><span class="n">getRayIntersectionFraction</span><span class="p">(</span><span class="n">Vector</span><span class="p">.</span><span class="n">zero</span><span class="p">,</span> <span class="n">relativeMotion</span><span class="p">);</span>

    <span class="c1">// check to see if a collision will happen this frame</span>
    <span class="c1">// getRayIntersectionFraction returns Math.POSITIVE_INFINITY if there is no intersection</span>
    <span class="k">if</span><span class="p">(</span><span class="n">h</span> <span class="o">&lt;</span> <span class="n">Math</span><span class="p">.</span><span class="n">POSITIVE_INFINITY</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// yup, there WILL be a collision this frame</span>
        <span class="c1">// move the boxes appropriately</span>
        <span class="n">boxA</span><span class="p">.</span><span class="n">center</span> <span class="o">+=</span> <span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">h</span><span class="p">;</span>
        <span class="n">boxB</span><span class="p">.</span><span class="n">center</span> <span class="o">+=</span> <span class="n">boxB</span><span class="p">.</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">dt</span> <span class="o">*</span> <span class="n">h</span><span class="p">;</span>

        <span class="c1">// zero the normal component of the velocity</span>
        <span class="c1">// (project the velocity onto the tangent of the relative velocities</span>
        <span class="c1">//  and only keep the projected component, tossing the normal component)</span>
        <span class="kd">var</span> tangent<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">relativeMotion</span><span class="p">.</span><span class="n">normalized</span><span class="p">.</span><span class="n">tangent</span><span class="p">;</span>
        <span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">.</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span><span class="p">,</span> <span class="n">tangent</span><span class="p">)</span> <span class="o">*</span> <span class="n">tangent</span><span class="p">;</span>
        <span class="n">boxB</span><span class="p">.</span><span class="n">velocity</span> <span class="o">=</span> <span class="n">Vector</span><span class="p">.</span><span class="n">dotProduct</span><span class="p">(</span><span class="n">boxB</span><span class="p">.</span><span class="n">velocity</span><span class="p">,</span> <span class="n">tangent</span><span class="p">)</span> <span class="o">*</span> <span class="n">tangent</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span>
    <span class="p">{</span>
        <span class="c1">// no intersection, move it along</span>
        <span class="n">boxA</span><span class="p">.</span><span class="n">center</span> <span class="o">+=</span> <span class="n">boxA</span><span class="p">.</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
        <span class="n">boxB</span><span class="p">.</span><span class="n">center</span> <span class="o">+=</span> <span class="n">boxB</span><span class="p">.</span><span class="n">velocity</span> <span class="o">*</span> <span class="n">dt</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</pre></div><p>We just need a couple more helper functions in our AABB class:</p><div class="highlight"><pre><span></span><span class="c1">// taken from https://github.com/pgkelley4/line-segments-intersect/blob/master/js/line-segments-intersect.js</span>
<span class="c1">// which was adapted from http://stackoverflow.com/questions/563198/how-do-you-detect-where-two-line-segments-intersect</span>
<span class="c1">// returns the point where they intersect (if they intersect)</span>
<span class="c1">// returns Math.POSITIVE_INFINITY if they don&#39;t intersect</span>
<span class="kd">private</span> <span class="kd">function</span> <span class="nf">getRayIntersectionFractionOfFirstRay</span><span class="p">(</span><span class="n">originA</span><span class="p">:</span><span class="n">Vector</span><span class="p">,</span> <span class="n">endA</span><span class="p">:</span><span class="n">Vector</span><span class="p">,</span> <span class="n">originB</span><span class="p">:</span><span class="n">Vector</span><span class="p">,</span> <span class="n">endB</span><span class="p">:</span><span class="n">Vector</span><span class="p">):</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="kd">var</span> r<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">endA</span> <span class="o">-</span> <span class="n">originA</span><span class="p">;</span>
    <span class="kd">var</span> s<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">endB</span> <span class="o">-</span> <span class="n">originB</span><span class="p">;</span>

    <span class="kd">var</span> numerator<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">(</span><span class="n">originB</span> <span class="o">-</span> <span class="n">originA</span><span class="p">)</span> <span class="o">*</span> <span class="n">r</span><span class="p">;</span>
    <span class="kd">var</span> denominator<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">r</span> <span class="o">*</span> <span class="n">s</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">numerator</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// the lines are co-linear</span>
        <span class="c1">// check if they overlap</span>
        <span class="c1">// todo: calculate intersection point</span>
        <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="n">POSITIVE_INFINITY</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">denominator</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// lines are parallel</span>
        <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="n">POSITIVE_INFINITY</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kd">var</span> u<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">numerator</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">;</span>
    <span class="kd">var</span> t<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="p">((</span><span class="n">originB</span> <span class="o">-</span> <span class="n">originA</span><span class="p">)</span> <span class="o">*</span> <span class="n">s</span><span class="p">)</span> <span class="o">/</span> <span class="n">denominator</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">((</span><span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">t</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">u</span> <span class="o">&lt;=</span> <span class="mi">1</span><span class="p">))</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">t</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">Math</span><span class="p">.</span><span class="n">POSITIVE_INFINITY</span><span class="p">;</span>
<span class="p">}</span>

<span class="kd">public</span> <span class="kd">function</span> <span class="nf">getRayIntersectionFraction</span><span class="p">(</span><span class="n">origin</span><span class="p">:</span><span class="n">Vector</span><span class="p">,</span> <span class="n">direction</span><span class="p">:</span><span class="n">Vector</span><span class="p">):</span><span class="n">Float</span>
<span class="p">{</span>
    <span class="kd">var</span> end<span class="p">:</span><span class="n">Vector</span> <span class="o">=</span> <span class="n">origin</span> <span class="o">+</span> <span class="n">direction</span><span class="p">;</span>

    <span class="c1">// for each of the AABB&#39;s four edges</span>
    <span class="c1">// calculate the minimum fraction of &quot;direction&quot;</span>
    <span class="c1">// in order to find where the ray FIRST intersects</span>
    <span class="c1">// the AABB (if it ever does)</span>
    <span class="kd">var</span> minT<span class="p">:</span><span class="n">Float</span> <span class="o">=</span> <span class="n">getRayIntersectionFractionOfFirstRay</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
    <span class="kd">var</span> x<span class="p">:</span><span class="n">Float</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">getRayIntersectionFractionOfFirstRay</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">minT</span><span class="p">)</span>
        <span class="n">minT</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">getRayIntersectionFractionOfFirstRay</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">max</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">minT</span><span class="p">)</span>
        <span class="n">minT</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">getRayIntersectionFractionOfFirstRay</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">max</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">),</span> <span class="k">new</span> <span class="n">Vector</span><span class="p">(</span><span class="n">min</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">min</span><span class="p">.</span><span class="n">y</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">&lt;</span> <span class="n">minT</span><span class="p">)</span>
        <span class="n">minT</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>

    <span class="c1">// ok, now we should have found the fractional component along the ray where we collided</span>
    <span class="k">return</span> <span class="n">minT</span><span class="p">;</span>
<span class="p">}</span>
</pre></div><p>And that’s pretty much it! Not too much more work to ensure that two AABBs <strong>always</strong> collide no matter how fast each of them is moving! A demo showing this functionality off is shown below:</p><figure><embed src="/images/swept-aabb-collision-minkowski/platformer.swf" width="500" height="500"><figcaption>No matter how fast the small AABB moves, it never tunnels through the platform. Use the buttons in the top left to try moving it at different speeds. The Minkowski AABB is blue. The origin is represented by a white dot, the relative motion vector is a red or green line extending from this dot (the colour depends on whether it intersects with the Minkowski AABB). Note that you can also use the <kbd>W</kbd>, <kbd>A</kbd>, and <kbd>D</kbd> keys to move the small AABB around.</figcaption></figure><p>The full source code for this demo <a href="https://gist.github.com/hamaluik/e69f96e253a190273bf0">is up on Github</a>. If you have any questions, comments, or concerns, I would love to hear from you! I only learned this method of continuous collision detection today, so there’s bound to be some things I missed.</p></article><footer><span>© 2020 <a href="https://hamaluik.ca">Kenton Hamaluik</a></span></footer></body></html>